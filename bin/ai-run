#!/usr/bin/env bash
set -e

TOOL="$1"
shift

# Parse flags
SHELL_MODE=false
NETWORK_FLAG=false
NETWORK_ARG=""
TOOL_ARGS=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --shell|-s)
      SHELL_MODE=true
      shift
      ;;
    --network|-n)
      NETWORK_FLAG=true
      shift
      # Check if next arg is a network name (not another flag)
      if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
        NETWORK_ARG="$1"
        shift
      fi
      ;;
    *)
      TOOL_ARGS+=("$1")
      shift
      ;;
  esac
done

WORKSPACES_FILE="$HOME/.ai-workspaces"
CURRENT_DIR="$(pwd)"
ENV_FILE="$HOME/.ai-env"

# Check if workspaces file exists
if [[ ! -f "$WORKSPACES_FILE" ]]; then
  echo "‚ùå Workspaces not configured. Run setup.sh first."
  exit 1
fi

# Check if current directory is inside any whitelisted workspace
ALLOWED=false
while IFS= read -r ws; do
  if [[ "$CURRENT_DIR" == "$ws"* ]]; then
    ALLOWED=true
    break
  fi
done < "$WORKSPACES_FILE"

if [[ "$ALLOWED" != "true" ]]; then
  echo "‚ö†Ô∏è  SECURITY WARNING: You are running $TOOL outside a whitelisted workspace."
  echo "   Current path: $CURRENT_DIR"
  echo ""
  echo "Allowing this path gives the AI container access to this folder."

  # Only prompt if running interactively (TTY attached)
  if [[ -t 0 ]]; then
    read -p "Do you want to whitelist the current directory? [y/N]: " CONFIRM
    if [[ "$CONFIRM" =~ ^[Yy]$ ]]; then
      echo "$CURRENT_DIR" >> "$WORKSPACES_FILE"
      echo "‚úÖ Added $CURRENT_DIR to $WORKSPACES_FILE"
    else
      echo "‚ùå Operation cancelled. Access denied."
      echo "üìÅ Allowed workspaces:"
      cat "$WORKSPACES_FILE"
      exit 1
    fi
  else
    # Non-interactive: fail securely
    echo "‚ùå Access denied (non-interactive mode). Please add this path manually:"
    echo "   echo '$CURRENT_DIR' >> $WORKSPACES_FILE"
    echo "üìÅ Allowed workspaces:"
    cat "$WORKSPACES_FILE"
    exit 1
  fi
fi

# Image source selection: local or registry (GitLab)
# Set AI_IMAGE_SOURCE=registry in ~/.ai-env to use pre-built images
AI_IMAGE_SOURCE="${AI_IMAGE_SOURCE:-local}"

if [[ "$AI_IMAGE_SOURCE" == "registry" ]]; then
  IMAGE="registry.gitlab.com/kokorolee/ai-sandbox-wrapper/ai-${TOOL}:latest"
else
  IMAGE="ai-${TOOL}:latest"
fi

CACHE_DIR="$HOME/.ai-cache/$TOOL"
HOME_DIR="$HOME/.ai-home/$TOOL"

mkdir -p "$CACHE_DIR" "$HOME_DIR"

# Build volume mounts for all whitelisted workspaces
VOLUME_MOUNTS=""
while IFS= read -r ws; do
  VOLUME_MOUNTS="$VOLUME_MOUNTS -v $ws:$ws:delegated"
done < "$WORKSPACES_FILE"

# Tool-specific config mounts (project-level takes precedence over global)
CONFIG_MOUNT=""
PROJECT_CONFIG="$CURRENT_DIR/.$TOOL.json"

if [[ -f "$PROJECT_CONFIG" ]]; then
  # Use project-level config if it exists
  CONFIG_MOUNT="-v $PROJECT_CONFIG:$CURRENT_DIR/.$TOOL.json:delegated"
else
  # Use global configs based on tool
  case "$TOOL" in
    amp)
      CONFIG_DIR="$HOME/.config/amp"
      DATA_DIR="$HOME/.local/share/amp"
      mkdir -p "$CONFIG_DIR" "$DATA_DIR"
      CONFIG_MOUNT="-v $CONFIG_DIR:/home/agent/.config/amp:delegated -v $DATA_DIR:/home/agent/.local/share/amp:delegated"
      ;;
    opencode)
      CONFIG_DIR="$HOME/.config/opencode"
      mkdir -p "$CONFIG_DIR"
      CONFIG_MOUNT="-v $CONFIG_DIR:/home/agent/.config/opencode:delegated"
      ;;
    claude)
      CONFIG_DIR="$HOME/.claude"
      mkdir -p "$CONFIG_DIR"
      CONFIG_MOUNT="-v $CONFIG_DIR:/home/agent/.claude:delegated"
      ;;
    droid)
      CONFIG_DIR="$HOME/.config/droid"
      mkdir -p "$CONFIG_DIR"
      CONFIG_MOUNT="-v $CONFIG_DIR:/home/agent/.config/droid:delegated"
      ;;
    qoder)
      CONFIG_DIR="$HOME/.config/qoder"
      mkdir -p "$CONFIG_DIR"
      CONFIG_MOUNT="-v $CONFIG_DIR:/home/agent/.config/qoder:delegated"
      ;;
    auggie)
      CONFIG_DIR="$HOME/.config/auggie"
      mkdir -p "$CONFIG_DIR"
      CONFIG_MOUNT="-v $CONFIG_DIR:/home/agent/.config/auggie:delegated"
      ;;
    codebuddy)
      CONFIG_DIR="$HOME/.config/codebuddy"
      mkdir -p "$CONFIG_DIR"
      CONFIG_MOUNT="-v $CONFIG_DIR:/home/agent/.config/codebuddy:delegated"
      ;;
    jules)
      CONFIG_DIR="$HOME/.config/jules"
      mkdir -p "$CONFIG_DIR"
      CONFIG_MOUNT="-v $CONFIG_DIR:/home/agent/.config/jules:delegated"
      ;;
    shai)
      CONFIG_DIR="$HOME/.config/shai"
      mkdir -p "$CONFIG_DIR"
      CONFIG_MOUNT="-v $CONFIG_DIR:/home/agent/.config/shai:delegated"
      ;;
  esac
fi

# ============================================================================
# NETWORK CONFIGURATION
# ============================================================================

AI_SANDBOX_CONFIG="$HOME/.ai-sandbox/config.json"

# Ensure jq is available (fallback to basic parsing if not)
has_jq() {
  command -v jq &>/dev/null
}

# Initialize config file if it doesn't exist
init_config() {
  mkdir -p "$(dirname "$AI_SANDBOX_CONFIG")"
  if [[ ! -f "$AI_SANDBOX_CONFIG" ]]; then
    echo '{"version":1,"networks":{"global":[],"workspaces":{}}}' > "$AI_SANDBOX_CONFIG"
    chmod 600 "$AI_SANDBOX_CONFIG"
  fi
}

# Read networks for current workspace (workspace > global > empty)
read_network_config() {
  init_config
  local workspace="$CURRENT_DIR"
  
  if has_jq; then
    # Try workspace-specific first
    local ws_networks=$(jq -r --arg ws "$workspace" '.networks.workspaces[$ws] // empty | .[]?' "$AI_SANDBOX_CONFIG" 2>/dev/null)
    if [[ -n "$ws_networks" ]]; then
      echo "$ws_networks"
      return
    fi
    # Fall back to global
    jq -r '.networks.global[]?' "$AI_SANDBOX_CONFIG" 2>/dev/null
  else
    # Fallback: grep-based parsing (basic)
    grep -o '"global":\s*\[[^]]*\]' "$AI_SANDBOX_CONFIG" 2>/dev/null | grep -o '"[^"]*"' | tr -d '"' | grep -v global
  fi
}

# Write networks to config (scope: workspace or global)
write_network_config() {
  local scope="$1"  # "workspace" or "global"
  shift
  local networks=("$@")
  
  init_config
  
  if has_jq; then
    local json_array=$(printf '%s\n' "${networks[@]}" | jq -R . | jq -s .)
    
    if [[ "$scope" == "workspace" ]]; then
      jq --arg ws "$CURRENT_DIR" --argjson nets "$json_array" \
        '.networks.workspaces[$ws] = $nets' "$AI_SANDBOX_CONFIG" > "$AI_SANDBOX_CONFIG.tmp" \
        && mv "$AI_SANDBOX_CONFIG.tmp" "$AI_SANDBOX_CONFIG"
    else
      jq --argjson nets "$json_array" \
        '.networks.global = $nets' "$AI_SANDBOX_CONFIG" > "$AI_SANDBOX_CONFIG.tmp" \
        && mv "$AI_SANDBOX_CONFIG.tmp" "$AI_SANDBOX_CONFIG"
    fi
    chmod 600 "$AI_SANDBOX_CONFIG"
  else
    echo "‚ö†Ô∏è  jq not found. Please install jq to save network configuration."
    return 1
  fi
}

# Validate networks exist, return only valid ones
validate_networks() {
  local networks=("$@")
  local valid=()
  
  for net in "${networks[@]}"; do
    [[ -z "$net" ]] && continue
    if docker network inspect "$net" &>/dev/null; then
      valid+=("$net")
    fi
  done
  
  printf '%s\n' "${valid[@]}"
}

# Discover Docker Compose networks (have com.docker.compose.project label)
discover_compose_networks() {
  docker network ls --filter "label=com.docker.compose.project" --format "{{.Name}}" 2>/dev/null | sort
}

# Discover custom networks (not system, not compose)
discover_custom_networks() {
  local compose_nets=$(discover_compose_networks)
  docker network ls --format "{{.Name}}" 2>/dev/null | while read -r net; do
    # Skip system networks
    [[ "$net" == "bridge" || "$net" == "host" || "$net" == "none" ]] && continue
    # Skip compose networks
    echo "$compose_nets" | grep -q "^${net}$" && continue
    echo "$net"
  done | sort
}

# Get containers in a network
get_network_containers() {
  local network="$1"
  docker network inspect "$network" --format '{{range .Containers}}{{.Name}} {{end}}' 2>/dev/null | xargs | tr ' ' ', '
}

# Interactive network selection menu (multi-select)
show_network_menu() {
  local compose_nets=()
  local custom_nets=()
  local all_nets=()
  local selected=()
  
  echo "üîç Discovering Docker networks..."
  echo ""
  
  # Gather networks
  while IFS= read -r net; do
    [[ -n "$net" ]] && compose_nets+=("$net")
  done < <(discover_compose_networks)
  
  while IFS= read -r net; do
    [[ -n "$net" ]] && custom_nets+=("$net")
  done < <(discover_custom_networks)
  
  # Build combined list: select-all first, then compose, then custom, then "none"
  # Index layout: [0]=select-all, [1..compose_count]=compose, [compose_count+1..custom_end]=custom, [last]=none
  local network_count=$((${#compose_nets[@]} + ${#custom_nets[@]}))
  all_nets=("select-all" "${compose_nets[@]}" "${custom_nets[@]}" "none")
  
  if [[ $network_count -eq 0 ]]; then
    echo "‚ÑπÔ∏è  No Docker networks found (besides system networks)."
    SELECTED_NETWORKS=()
    return 0
  fi
  
  # Initialize selection array (none is pre-selected)
  local sel=()
  local select_all_idx=0
  local compose_start=1
  local compose_end=$((1 + ${#compose_nets[@]}))
  local custom_start=$compose_end
  local none_idx=$((${#all_nets[@]} - 1))
  
  for ((i=0; i<${#all_nets[@]}; i++)); do
    if [[ "${all_nets[$i]}" == "none" ]]; then
      sel[$i]=1
    else
      sel[$i]=0
    fi
  done
  
  local cursor=0
  
  tput civis
  trap 'tput cnorm' INT TERM EXIT
  
  while true; do
    clear
    echo "üîó Network Selection"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo ""
    
    # Select All option
    local check="[ ]"
    [[ ${sel[$select_all_idx]} -eq 1 ]] && check="[x]"
    if [[ $cursor -eq $select_all_idx ]]; then
      tput setaf 6
      printf "  ‚ûî %s Select All\n" "$check"
    else
      printf "    %s Select All\n" "$check"
    fi
    tput sgr0
    echo ""
    
    # Compose Networks section
    if [[ ${#compose_nets[@]} -gt 0 ]]; then
      echo "Compose Networks:"
      for ((i=compose_start; i<compose_end; i++)); do
        local net="${all_nets[$i]}"
        local containers=$(get_network_containers "$net")
        local check="[ ]"
        [[ ${sel[$i]} -eq 1 ]] && check="[x]"
        
        if [[ $i -eq $cursor ]]; then
          tput setaf 6
          printf "  ‚ûî %s %-30s" "$check" "$net"
        else
          printf "    %s %-30s" "$check" "$net"
        fi
        
        if [[ -n "$containers" ]]; then
          tput setaf 8
          printf " (%s)" "$containers"
        fi
        tput sgr0
        echo ""
      done
      echo ""
    fi
    
    # Custom Networks section
    if [[ ${#custom_nets[@]} -gt 0 ]]; then
      echo "Other Networks:"
      for ((i=custom_start; i<none_idx; i++)); do
        local net="${all_nets[$i]}"
        local containers=$(get_network_containers "$net")
        local check="[ ]"
        [[ ${sel[$i]} -eq 1 ]] && check="[x]"
        
        if [[ $i -eq $cursor ]]; then
          tput setaf 6
          printf "  ‚ûî %s %-30s" "$check" "$net"
        else
          printf "    %s %-30s" "$check" "$net"
        fi
        
        if [[ -n "$containers" ]]; then
          tput setaf 8
          printf " (%s)" "$containers"
        fi
        tput sgr0
        echo ""
      done
      echo ""
    fi
    
    # None option
    echo ""
    local check="[ ]"
    [[ ${sel[$none_idx]} -eq 1 ]] && check="[x]"
    if [[ $cursor -eq $none_idx ]]; then
      tput setaf 6
      printf "  ‚ûî %s None (no network)\n" "$check"
    else
      printf "    %s None (no network)\n" "$check"
    fi
    tput sgr0
    
    echo ""
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "‚Üë‚Üì Move  SPACE Select  a Select All  ENTER Confirm"
    
    # Read input
    IFS= read -rsn1 key
    if [[ "$key" == $'\x1b' ]]; then
      read -rsn2 -t 1 escape_seq
      case "$escape_seq" in
        '[A') ((cursor > 0)) && ((cursor--)) ;;
        '[B') ((cursor < ${#all_nets[@]} - 1)) && ((cursor++)) ;;
      esac
    else
      case "$key" in
        ' ')
          # Toggle selection
          if [[ $cursor -eq $select_all_idx ]]; then
            # Toggle select all
            if [[ ${sel[$select_all_idx]} -eq 1 ]]; then
              # Deselect all, select none
              for ((i=0; i<${#all_nets[@]}; i++)); do sel[$i]=0; done
              sel[$none_idx]=1
            else
              # Select all networks, deselect none
              for ((i=0; i<${#all_nets[@]}; i++)); do sel[$i]=1; done
              sel[$none_idx]=0
            fi
          elif [[ $cursor -eq $none_idx ]]; then
            # Selecting "none" clears all others
            for ((i=0; i<${#all_nets[@]}; i++)); do sel[$i]=0; done
            sel[$none_idx]=1
          else
            # Selecting a network clears "none" and updates select-all state
            sel[$none_idx]=0
            if [[ ${sel[$cursor]} -eq 1 ]]; then
              sel[$cursor]=0
              sel[$select_all_idx]=0
            else
              sel[$cursor]=1
              # Check if all networks are now selected
              local all_selected=1
              for ((i=compose_start; i<none_idx; i++)); do
                [[ ${sel[$i]} -eq 0 ]] && all_selected=0 && break
              done
              sel[$select_all_idx]=$all_selected
            fi
          fi
          ;;
        'a'|'A')
          # Quick select all
          for ((i=0; i<${#all_nets[@]}; i++)); do sel[$i]=1; done
          sel[$none_idx]=0
          ;;
        ''|$'\n'|$'\r')
          break
          ;;
        k) ((cursor > 0)) && ((cursor--)) ;;
        j) ((cursor < ${#all_nets[@]} - 1)) && ((cursor++)) ;;
      esac
    fi
  done
  
  tput cnorm
  trap - INT TERM EXIT
  
  # Collect selected networks (exclude select-all and none)
  SELECTED_NETWORKS=()
  for ((i=1; i<${#all_nets[@]}; i++)); do
    if [[ ${sel[$i]} -eq 1 && "${all_nets[$i]}" != "none" && "${all_nets[$i]}" != "select-all" ]]; then
      SELECTED_NETWORKS+=("${all_nets[$i]}")
    fi
  done
}

# Save prompt after selection
show_save_prompt() {
  local options=("This workspace" "Global (all workspaces)" "Don't save")
  local cursor=0
  
  echo ""
  
  tput civis
  trap 'tput cnorm' INT TERM EXIT
  
  while true; do
    # Move cursor up to redraw (3 options + header)
    tput cuu 5 2>/dev/null || true
    tput ed 2>/dev/null || true
    
    echo "Save selection?"
    for ((i=0; i<${#options[@]}; i++)); do
      if [[ $i -eq $cursor ]]; then
        tput setaf 6
        if [[ $i -eq 0 ]]; then
          printf "  ‚ûî %s (%s)\n" "${options[$i]}" "$CURRENT_DIR"
        else
          printf "  ‚ûî %s\n" "${options[$i]}"
        fi
      else
        if [[ $i -eq 0 ]]; then
          printf "    %s (%s)\n" "${options[$i]}" "$CURRENT_DIR"
        else
          printf "    %s\n" "${options[$i]}"
        fi
      fi
      tput sgr0
    done
    
    IFS= read -rsn1 key
    if [[ "$key" == $'\x1b' ]]; then
      read -rsn2 -t 1 escape_seq
      case "$escape_seq" in
        '[A') ((cursor > 0)) && ((cursor--)) ;;
        '[B') ((cursor < 2)) && ((cursor++)) ;;
      esac
    else
      case "$key" in
        ''|$'\n'|$'\r') break ;;
        k) ((cursor > 0)) && ((cursor--)) ;;
        j) ((cursor < 2)) && ((cursor++)) ;;
      esac
    fi
  done
  
  tput cnorm
  trap - INT TERM EXIT
  
  SAVE_CHOICE=$cursor  # 0=workspace, 1=global, 2=don't save
}

# Network configuration
NETWORK_OPTIONS=""
HOST_ACCESS_ARGS="--add-host=host.docker.internal:host-gateway"
SELECTED_NETWORKS=()

if [[ "$NETWORK_FLAG" == "true" ]]; then
  if [[ -n "$NETWORK_ARG" ]]; then
    # Direct specification: -n net1,net2
    IFS=',' read -ra SELECTED_NETWORKS <<< "$NETWORK_ARG"
  elif [[ -t 0 ]]; then
    # Interactive mode: show menu
    show_network_menu
    
    if [[ ${#SELECTED_NETWORKS[@]} -gt 0 ]]; then
      show_save_prompt
      case $SAVE_CHOICE in
        0) write_network_config "workspace" "${SELECTED_NETWORKS[@]}" && echo "‚úÖ Saved for this workspace" ;;
        1) write_network_config "global" "${SELECTED_NETWORKS[@]}" && echo "‚úÖ Saved globally" ;;
        *) echo "‚ÑπÔ∏è  Using for this session only" ;;
      esac
    fi
  else
    echo "‚ö†Ô∏è  Non-interactive mode. Use -n network1,network2 to specify networks."
  fi
else
  # No flag: use saved config silently
  while IFS= read -r net; do
    [[ -n "$net" ]] && SELECTED_NETWORKS+=("$net")
  done < <(read_network_config)
fi

# Validate and build network options
if [[ ${#SELECTED_NETWORKS[@]} -gt 0 ]]; then
  while IFS= read -r net; do
    [[ -n "$net" ]] && NETWORK_OPTIONS="$NETWORK_OPTIONS --network $net"
  done < <(validate_networks "${SELECTED_NETWORKS[@]}")
fi

# Git access control (opt-in per workspace)
GIT_MOUNTS=""
GIT_ALLOWED_FILE="$HOME/.ai-git-allowed"
GIT_CACHE_DIR="$HOME/.ai-cache/git"
touch "$GIT_ALLOWED_FILE"

# Check if Git access is allowed for this workspace
if grep -q "^$CURRENT_DIR$" "$GIT_ALLOWED_FILE" 2>/dev/null; then
  # Previously allowed for this workspace
  # Check if saved keys exist for this workspace
  WORKSPACE_MD5=$(echo "$CURRENT_DIR" | md5sum | cut -c1-8)
  SAVED_KEYS_FILE="$HOME/.ai-git-keys-$WORKSPACE_MD5"

  if [ -f "$SAVED_KEYS_FILE" ]; then
    # Use previously saved key selection
    echo "üìã Syncing Git credentials..."
    if [ -d "$GIT_CACHE_DIR/ssh" ]; then
      chmod -R 700 "$GIT_CACHE_DIR/ssh" 2>/dev/null || true
      rm -rf "$GIT_CACHE_DIR/ssh"
    fi
    mkdir -p "$GIT_CACHE_DIR/ssh"

    # Read saved keys and copy them
    SAVED_KEYS=()
    while IFS= read -r key; do
      [ -n "$key" ] && SAVED_KEYS+=("$key")
    done < "$SAVED_KEYS_FILE"

    for key in "${SAVED_KEYS[@]}"; do
      [ -z "$key" ] && continue
      src_file="$HOME/.ssh/$key"
      dst_file="$GIT_CACHE_DIR/ssh/$key"

      dst_dir=$(dirname "$dst_file")
      mkdir -p "$dst_dir"
      chmod 700 "$dst_dir"

      if [ -f "$src_file" ]; then
        cp "$src_file" "$dst_file"
        chmod 600 "$dst_file"
      fi
    done

    # Copy filtered SSH config (only hosts needed for this repo)
    if [ -f "$HOME/.ssh/config" ]; then
      SETUP_SSH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/setup-ssh-config"
      if [ -x "$SETUP_SSH" ]; then
        # Join SAVED_KEYS into a comma-separated string for --keys
        KEYS_ARG=$(IFS=,; echo "${SAVED_KEYS[*]}")
        output=$("$SETUP_SSH" --keys "$KEYS_ARG" 2>&1)
        TEMP_CONFIG=$(echo "$output" | grep "Config:" | tail -1 | awk '{print $NF}')
        if [ -f "$TEMP_CONFIG" ]; then
          cp "$TEMP_CONFIG" "$GIT_CACHE_DIR/ssh/config"
          chmod 600 "$GIT_CACHE_DIR/ssh/config"
        else
          cp "$HOME/.ssh/config" "$GIT_CACHE_DIR/ssh/config"
          chmod 600 "$GIT_CACHE_DIR/ssh/config"
        fi
      else
        cp "$HOME/.ssh/config" "$GIT_CACHE_DIR/ssh/config"
        chmod 600 "$GIT_CACHE_DIR/ssh/config"
      fi
    fi

    if [ -f "$HOME/.ssh/known_hosts" ]; then
      cp "$HOME/.ssh/known_hosts" "$GIT_CACHE_DIR/ssh/known_hosts"
      chmod 600 "$GIT_CACHE_DIR/ssh/known_hosts"
    fi

    # Ensure all directories have correct permissions (recursive)
    chmod 700 "$GIT_CACHE_DIR/ssh"
    find "$GIT_CACHE_DIR/ssh" -type d -exec chmod 700 {} \;
    find "$GIT_CACHE_DIR/ssh" -type f ! -name "config" ! -name "known_hosts" -exec chmod 600 {} \;

    GIT_MOUNTS="$GIT_MOUNTS -v $GIT_CACHE_DIR/ssh:/home/agent/.ssh:ro"
    echo "‚úÖ Git credentials synced"
  fi

  if [ -f "$HOME/.gitconfig" ]; then
    # Copy gitconfig to HOME_DIR (can't mount file inside mounted directory)
    cp "$HOME/.gitconfig" "$HOME_DIR/.gitconfig" 2>/dev/null || true
  fi
else
  # Ask user if they want Git access for this workspace (only in interactive mode)
  if [[ -t 0 ]] && ([ -d "$HOME/.ssh" ] || [ -f "$HOME/.gitconfig" ]); then
    echo ""
    echo "üîê Git Access Control"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "Allow AI tool to access Git credentials for this workspace?"
    echo "Workspace: $CURRENT_DIR"
    echo ""
    echo "  1) Yes, allow once (this session only)"
    echo "  2) Yes, always allow for this workspace"
    echo "  3) No, keep Git disabled (secure default)"
    echo ""
    read -p "Choice [1-3]: " git_choice

    case "$git_choice" in
      1|2)
        # Interactive SSH key selection
        echo ""
        echo "üîë SSH Key Selection"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

        # Source the SSH key selector library
        # Resolve symlink to get actual project directory
        SCRIPT_PATH="${BASH_SOURCE[0]}"
        while [ -L "$SCRIPT_PATH" ]; do
          SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
          SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
          [[ $SCRIPT_PATH != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
        done
        SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
        source "$SCRIPT_DIR/../lib/ssh-key-selector.sh"

        # Let user select keys
        if select_ssh_keys; then
          if [ ${#SELECTED_SSH_KEYS[@]} -gt 0 ]; then
            echo "üìã Copying selected credentials to cache..."
            if [ -d "$GIT_CACHE_DIR/ssh" ]; then
              chmod -R 700 "$GIT_CACHE_DIR/ssh" 2>/dev/null || true
              rm -rf "$GIT_CACHE_DIR/ssh"
            fi
            mkdir -p "$GIT_CACHE_DIR/ssh"

            # Copy selected SSH keys (preserve directory structure exactly)
            for key in "${SELECTED_SSH_KEYS[@]}"; do
              echo "  ‚Üí Copying $key..."
              src_file="$HOME/.ssh/$key"
              dst_file="$GIT_CACHE_DIR/ssh/$key"

              # Create parent directory with correct permissions
              dst_dir=$(dirname "$dst_file")
              mkdir -p "$dst_dir"
              chmod 700 "$dst_dir"

              # Copy the file and set permissions
              if [ -f "$src_file" ]; then
                cp "$src_file" "$dst_file"
                chmod 600 "$dst_file"
              else
                echo "    ‚ö†Ô∏è  Warning: $src_file not found, skipping"
              fi
            done

            # Copy filtered SSH config (only hosts needed for this repo)
            if [ -f "$HOME/.ssh/config" ]; then
              echo "  ‚Üí Generating filtered SSH config..."
              # Run setup-ssh-config to get filtered config
              SETUP_SSH="$SCRIPT_DIR/setup-ssh-config"
              if [ -x "$SETUP_SSH" ]; then
                # Join SELECTED_SSH_KEYS into a comma-separated string for --keys
                KEYS_ARG=$(IFS=,; echo "${SELECTED_SSH_KEYS[*]}")
                # Run it and capture the filtered config path
                output=$("$SETUP_SSH" --keys "$KEYS_ARG" 2>&1)
                TEMP_CONFIG=$(echo "$output" | grep "Config:" | tail -1 | awk '{print $NF}')
                if [ -f "$TEMP_CONFIG" ]; then
                  cp "$TEMP_CONFIG" "$GIT_CACHE_DIR/ssh/config"
                  chmod 600 "$GIT_CACHE_DIR/ssh/config"
                else
                  # Fallback to copying full config if setup-ssh-config fails
                  cp "$HOME/.ssh/config" "$GIT_CACHE_DIR/ssh/config"
                  chmod 600 "$GIT_CACHE_DIR/ssh/config"
                fi
              else
                # Fallback: copy full config
                cp "$HOME/.ssh/config" "$GIT_CACHE_DIR/ssh/config"
                chmod 600 "$GIT_CACHE_DIR/ssh/config"
              fi
            fi

            if [ -f "$HOME/.ssh/known_hosts" ]; then
              echo "  ‚Üí Copying known_hosts..."
              cp "$HOME/.ssh/known_hosts" "$GIT_CACHE_DIR/ssh/known_hosts"
              chmod 600 "$GIT_CACHE_DIR/ssh/known_hosts"
            fi

            # Ensure all directories and files have correct permissions (recursive)
            chmod 700 "$GIT_CACHE_DIR/ssh"
            find "$GIT_CACHE_DIR/ssh" -type d -exec chmod 700 {} \;
            find "$GIT_CACHE_DIR/ssh" -type f ! -name "config" ! -name "known_hosts" -exec chmod 600 {} \;

            GIT_MOUNTS="$GIT_MOUNTS -v $GIT_CACHE_DIR/ssh:/home/agent/.ssh:ro"

            # Copy gitconfig
            if [ -f "$HOME/.gitconfig" ]; then
              echo "  ‚Üí Copying .gitconfig..."
              cp "$HOME/.gitconfig" "$HOME_DIR/.gitconfig" 2>/dev/null || true
            fi

            if [ "$git_choice" = "2" ]; then
              # Save workspace and selected keys for future sessions
              echo "$CURRENT_DIR" >> "$GIT_ALLOWED_FILE"
              # Save selected keys (one per line for easier parsing)
              WORKSPACE_MD5=$(echo "$CURRENT_DIR" | md5sum | cut -c1-8)
              printf "%s\n" "${SELECTED_SSH_KEYS[@]}" > "$HOME/.ai-git-keys-$WORKSPACE_MD5"
              echo "‚úÖ Git access enabled and saved for: $CURRENT_DIR"
            else
              echo "‚úÖ Git access enabled for this session"
            fi
          else
            echo "‚ö†Ô∏è  No SSH keys selected. Git access disabled."
          fi
        else
          echo "‚ö†Ô∏è  SSH key selection cancelled. Git access disabled."
        fi
        ;;
      *)
        # Default: no Git access
        echo "üîí Git access disabled (secure mode)"
        ;;
    esac
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo ""
  fi
fi

# Generate container name based on tool and folder
# Format: {tool}-{sanitized_folder_name}-{random_suffix}
generate_container_name() {
  local folder_name=$(basename "$CURRENT_DIR")
  
  # Sanitize: keep only alphanumeric, hyphens, underscores
  # Replace spaces with hyphens, remove special chars
  folder_name=$(echo "$folder_name" | tr ' ' '-' | tr -cd '[:alnum:]_-' | tr '[:upper:]' '[:lower:]')
  
  # Limit length (max 50 chars for container name, leaving room for random suffix)
  if [[ ${#folder_name} -gt 40 ]]; then
    folder_name="${folder_name:0:40}"
  fi
  
  # Remove trailing hyphens/underscores
  folder_name=$(echo "$folder_name" | sed 's/[-_]*$//')
  
  # If empty after sanitization, use "workspace"
  if [[ -z "$folder_name" ]]; then
    folder_name="workspace"
  fi
  
  # Generate random 6-character suffix (hex)
  local random_suffix=$(openssl rand -hex 3)
  
  echo "${TOOL}-${folder_name}-${random_suffix}"
}

# Container name and TTY allocation
CONTAINER_NAME=""
TTY_FLAGS="-it"  # Default to interactive mode

# Check if we have a proper TTY and are in interactive mode
if [[ ! -t 0 ]] || [[ ! -t 1 ]]; then
  # No TTY available or non-interactive mode
  TTY_FLAGS=""
  echo "‚ö†Ô∏è  Non-interactive mode detected. Terminal interface may be limited."
elif [[ -n "$CI" ]] || [[ -n "$GITHUB_ACTIONS" ]]; then
  # CI environment - disable interactive features
  TTY_FLAGS=""
  echo "‚ÑπÔ∏è  CI environment detected. Running in non-interactive mode."
fi

# Only set container name for interactive mode to avoid conflicts
if [[ -n "$TTY_FLAGS" ]]; then
  CONTAINER_NAME="--name $(generate_container_name)"
fi

# Port exposure configuration
PORT_MAPPINGS=""
if [[ -n "${PORT:-}" ]]; then
  PORT_BIND="${PORT_BIND:-localhost}"
  BIND_ADDR="127.0.0.1"
  
  if [[ "$PORT_BIND" == "all" ]]; then
    BIND_ADDR="0.0.0.0"
    echo "‚ö†Ô∏è  WARNING: Ports will be accessible from network (PORT_BIND=all)"
  fi
  
  IFS=',' read -ra PORTS <<< "$PORT"
  for port in "${PORTS[@]}"; do
    # Trim whitespace
    port=$(echo "$port" | tr -d ' ')
    # Validate port number (1-65535)
    if [[ "$port" =~ ^[0-9]+$ ]] && [ "$port" -ge 1 ] && [ "$port" -le 65535 ]; then
      PORT_MAPPINGS="$PORT_MAPPINGS -p $BIND_ADDR:$port:$port"
    else
      echo "‚ö†Ô∏è  WARNING: Invalid port number: $port (skipped)"
    fi
  done
  
  if [[ -n "$PORT_MAPPINGS" ]]; then
    echo "üîå Port mappings: ${PORT//,/ }"
  fi
fi

# Debug output (only in verbose mode)
if [[ "${AI_RUN_DEBUG:-}" == "1" ]]; then
  echo "üîß Debug: TTY_FLAGS='$TTY_FLAGS'"
  echo "üîß Debug: CONTAINER_NAME='$CONTAINER_NAME'"
  echo "üîß Debug: IMAGE='$IMAGE'"
  echo "üîß Debug: SHELL_MODE='$SHELL_MODE'"
  echo "üîß Debug: TOOL_ARGS='${TOOL_ARGS[@]}'"
  echo "üîß Debug: PORT='${PORT:-}'"
  echo "üîß Debug: PORT_BIND='${PORT_BIND:-localhost}'"
  echo "üîß Debug: PORT_MAPPINGS='$PORT_MAPPINGS'"
fi

# Prepare command based on mode
ENTRYPOINT_OVERRIDE=""
if [[ "$SHELL_MODE" == "true" ]]; then
  # Shell mode: override entrypoint to bash and show welcome message
  ENTRYPOINT_OVERRIDE="--entrypoint bash"
  DOCKER_COMMAND=(
    "-c"
    "echo ''; echo 'üöÄ AI Tool Container - Interactive Shell'; echo '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ'; echo ''; echo \"Tool available: ${TOOL}\"; echo 'Run the tool: ${TOOL}'; echo 'Exit container: exit or Ctrl+D'; echo ''; echo \"Additional tools:\"; echo '  - specify (spec-kit): Spec-driven development'; echo '  - uipro (ux-ui-promax): UI/UX design intelligence'; echo '  - openspec: OpenSpec workflow'; echo ''; echo '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ'; echo ''; exec bash"
  )
else
  # Direct mode: use image's default entrypoint with arguments
  DOCKER_COMMAND=("${TOOL_ARGS[@]}")
fi

# Detect platform architecture (avoid slow emulation)
PLATFORM="${AI_RUN_PLATFORM:-}"
if [[ -z "$PLATFORM" ]]; then
  case "$(uname -m)" in
    x86_64)
      PLATFORM="linux/amd64"
      ;;
    aarch64|arm64)
      PLATFORM="linux/arm64"
      ;;
    *)
      PLATFORM="linux/$(uname -m)"
      ;;
  esac
fi

# Terminal size for TUI apps (important for opencode, aider, etc.)
TERMINAL_SIZE=""
if [[ -n "$TTY_FLAGS" ]]; then
  # Get current terminal size
  TERM_COLS=$(tput cols 2>/dev/null || echo "120")
  TERM_LINES=$(tput lines 2>/dev/null || echo "40")
  TERMINAL_SIZE="-e COLUMNS=$TERM_COLS -e LINES=$TERM_LINES"
fi

docker run $CONTAINER_NAME --rm $TTY_FLAGS \
  --init \
  --platform "$PLATFORM" \
  $ENTRYPOINT_OVERRIDE \
  $VOLUME_MOUNTS \
  $CONFIG_MOUNT \
  $GIT_MOUNTS \
  $NETWORK_OPTIONS \
  $HOST_ACCESS_ARGS \
  $PORT_MAPPINGS \
  -v "$CACHE_DIR":/home/agent/.cache \
  -v "$HOME_DIR":/home/agent \
  -w "$CURRENT_DIR" \
  --env-file "$ENV_FILE" \
  -e TERM="$TERM" \
  -e COLORTERM="$COLORTERM" \
  $TERMINAL_SIZE \
  "$IMAGE" "${DOCKER_COMMAND[@]}"
